/*!
@class QtBackgroundProcess::App

Use this class instead of QCoreApplication to create a background process. You will either have
to override the startup/shutdown functions or set them with function objects.

@sa App::setupParser, App::startupApp, App::requestAppShutdown
*/

/*!
@property QtBackgroundProcess::App::instanceID

@default{<i>empty</i>, until exec() is called}

The instance ID is an id that is generated for an application to identify it on runtime. It
is the same for multiple instances of an application run by the same user/session, but unique
for every "application". It is used internally for the singleton instance and to connecte the
terminals to the correct master. Unless you need to run multiple master instances of the same
application, there is typically no need to modify this variable.

The id will be generated automatically as soon as you call App::exec. If you need the id before
that, you can generate it using App::createDefaultInstanceID.

@note The instance id is generated by using various information about the application. This
includes properties that can be set in the main, like QCoreApplication::setOrganizationName. In
order to include those, the generation is lazy. If you need to generate it on your own, make
shure to do so after those initializations.

@accessors{
	@readAc{instanceID()}
	@writeAc{setInstanceID()}
	@resetAc{createDefaultInstanceID()}
}

@sa App::exec
*/

/*!
@property QtBackgroundProcess::App::forwardMasterLog

@default{`false`}

If enabled, the master process will forward everything it writes to the logfile to all connected
terminals as well. This includes all qDebug, qWarning, etc. kinds of messages. If you want this
to work for all master messages, even before the startup function was called, set this true in
terminal scope, i.e. the main function. This property has no effect on terminals.

@accessors{
	@readAc{forwardMasterLog()}
	@writeAc{setForwardMasterLog()}
}

@sa GlobalTerminal, Terminal, App::startupApp
*/

/*!
@property QtBackgroundProcess::App::autoStartMaster

@default{`false`}

By default, you need to explicitly pass `start` as parameter to start the master process. If
you want this to happen automatically, set this property to `true` in terminal scope! Do it
before calling exec() in your main.

@note If the master is already running, this property has no effect

@accessors{
	@readAc{autoStartMaster()}
	@writeAc{setAutoStartMaster()}
}

@sa App::ignoreMultiStarts, App::exec
*/

/*!
@property QtBackgroundProcess::App::ignoreMultiStarts

@default{`false`}

By default, start commands will be passed to the master as is, if it is already running.
If you don't want this to happen, because you treat starts differently, set this property to
true. This will cause terminals that try to call start on a running master to discard **all**
arguments and connect with an empty arguments list.

@note This property only prevents explicit start calls. It does not interfere with the
App::autoStartMaster property.

@accessors{
	@readAc{ignoreMultiStarts()}
	@writeAc{setIgnoreMultiStarts()}
}

@sa App::autoStartMaster, App::startupApp
*/

/*!
@property QtBackgroundProcess::App::autoDeleteTerminals

@default{`true`}

If a terminal gets disconnected, the master can automatically delete it. Each terminal has
it's own property to enable/disable auto deletion. By setting this property, you can set the
default for newly created terminals. Disable it, if you handle terminals by yourself.

@note To change the Terminal::autoDelete for all already connected terminals, pass `true` as
second parameter to the set accessor

@accessors{
	@readAc{autoDeleteTerminals()}
	@writeAc{setAutoDeleteTerminals()}
}

@sa App::autoKillTerminals, Terminal::autoDelete
*/

/*!
@property QtBackgroundProcess::App::autoKillTerminals

@default{`false`}

If you don't want terminals to be able to attach to the master, and only want to use them to
receive new commands, you can enable this property. After receiving the command, the master
automatically disconnects the terminal and deletes it.

@note Setting this to true will prevent terminals from beeing added to the terminal list, and
will not emit newTerminalConnected() anymore. However, commandReceived() with the command of
the terminal is still beeing used.

@note To kill all already connected terminals, pass `true` as second parameter to the set
accessor

@accessors{
	@readAc{autoKillTerminals()}
	@writeAc{setAutoKillTerminals()}
}

@sa App::autoDeleteTerminals, App::commandReceived
*/

/*!
@property QtBackgroundProcess::App::connectedTerminals

@default{`[]`}

Every time a terminal was connected or disconnect, this property changes. This does **not**
include terminals that connect with the `--detached` option, as well as automatically killed
terminals.

@accessors{
	@readAc{connectedTerminals()}
	@notifyAc{connectedTerminalsChanged()}
	@notifyAc{newTerminalConnected() <i>(implicit)</i>}
}

@sa App::autoKillTerminals, App::commandReceived
*/

/*!
@fn QtBackgroundProcess::App::setParserSetupFunction

@param function The function to be called by App::setupParser

The handlers parameter are:
- the command line parser to be set up (QCommandLineParser &)

@note The parsers passed to this function are already set up with the options and arguments
required for the app itself. You can simply add your own ones.

@sa App::setupParser
*/

/*!
@fn QtBackgroundProcess::App::setStartupFunction

@param function The function to be called by App::startupApp

See App::startupApp for the handlers arguments.

@sa App::startupApp
*/

/*!
@fn QtBackgroundProcess::App::setShutdownRequestFunction(const std::function<bool(const QCommandLineParser &, int&)> &)

@param function The function to be called by App::requestAppShutdown

The handlers parameter are:
- a command line parser holding the stop arguments (QCommandLineParser)
- a reference to the exit code. Set this code if another value than `EXIT_SUCCESS` should be
returned by the app (int &)
- <i>returns:</i> `true` if the shutdown request should be accepted, `false` if not

@sa App::requestAppShutdown
*/

/*!
@fn QtBackgroundProcess::App::setShutdownRequestFunction(const std::function<bool(Terminal*, int&)> &)

@param function The function to be called by App::requestAppShutdown

See App::requestAppShutdown for the handlers arguments.

@sa App::requestAppShutdown
*/

/*!
@fn QtBackgroundProcess::App::exec

@inherit{QCoreApplication::exec}

@returns The applications exit code

A reimplementation of exec, to perform the neccesary steps to start the execution.

@attention It is very important you call **this** function, and **not** QCoreApplication::exec.
If you don't, the background process won't properly start

@sa App::startupApp
*/

/*!
@fn QtBackgroundProcess::App::createDefaultInstanceID

@param overwrite If set to `false` no id will be generated, if one already exists
@throws NotAllowedInRunningStateException Will be thrown if you try to change the instanceID
after the application has already been started

@sa App::exec
*/

/*!
@fn QtBackgroundProcess::App::setInstanceID

@param instanceID The instance id or the seed for the id
@param useAsSeed If set to yes, the instanceID will be used as a seed, and not set directly
@throws NotAllowedInRunningStateException Will be thrown if you try to change the instanceID
after the application has already been started

If useAsSeed is false, whatever you pass as instanceID is used as the new id. If set to true,
the id will be generated as usual, but with instanceID as seed to modify it. This has the
advantage of maintaining the uniqueness of the default instanceID, without beeing limit to a
single one.
*/

/*!
@fn QtBackgroundProcess::App::commandReceived

@param parser A command line parser, holding the arguments that have been sent to the master
@param isStarter If this arguments are the same that have been passed to App::startupApp, this
parameter will be `true`

@sa App::newTerminalConnected, Terminal::parser, Terminal::starter
*/

/*!
@fn QtBackgroundProcess::App::setupParser

@param parser The command line parser to be set up
@param useShortOptions Specify if short options should be enabled

You can override this function to add additional options and arguments to the apps command line
parser. The default implementation performs a basic setup and calls the handler set by
App::setParserSetupFunction, if available.
setup.

@attention In order to do the setup required by the app, you will have to call this
implementation in your override! The useShortOptions parameter will always be true. If you don't
want short options, pass a different value to the base implementation

Sample:
@code{.cpp}
void MyApp::setupParser(...)
{
	QtBackgroundProcess::App::setupParser(parser, useShortOptions);// or (parser, false)
	parser.addOption(...);
}
@endcode

@sa App::setParserSetupFunction
*/

/*!
@fn QtBackgroundProcess::App::startupApp

@param parser a command line parser holding the startup arguments
@returns The start exit code. Pass `EXIT_SUCCESS` to continue execution. Anything else will
induce an error and stop the master with the given code

You can override this function to add the code that should be run to startup the master
process. The default implementation calls the handler set by App::setStartupFunction, if
available.

@sa App::setStartupFunction
*/

/*!
@fn QtBackgroundProcess::App::requestAppShutdown

@param terminal The terminal that requested the shutdown
@param exitCode A reference to the exit code. Set this code if another value than
`EXIT_SUCCESS` should be returned by the app. Ignored if not returning `true`
@returns `true` if the shutdown request should be accepted, `false` if not

You can override this function to decide whether your application should accept the stop
command and shut down (return `true`) or ignore it (return `false`). The default implementation
calls the handler set by App::setStartupFunction, if available, or simply returns `true`, if
no handler has been set.

@sa App::setStartupFunction
*/
